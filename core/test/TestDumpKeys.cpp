//
// Created by fionser on 8/26/16.
//
#include "HElib/FHE.h"
#include <vector>
#include <fstream>
void gen() {
    /// Generate context, pk and sk;, and dump into files.
    FHEcontext context(1024, 1031, 1);
    buildModChain(context, 10);
    FHESecKey sk(context);
    sk.GenSecKey(64);
    FHEPubKey pk = sk;
    std::ofstream outstream("pk.pk", std::ios::binary);
    std::ofstream outstream2("context", std::ios::binary);
    printf("%f\n", context.securityLevel());
    if (outstream.is_open()) {
        writeContextBase(outstream2, context);
        outstream2 << context;
        outstream << pk;
        outstream.close();
        outstream2.close();
    }

    std::ofstream o("sk.sk", std::ios::binary);
    o << sk;
    o.close();
}

void test() {
    vector<long> gens, ords;
    unsigned long m, p, r;
    std::ifstream instream("pk.pk", std::ios::binary);
    std::ifstream instream2("context", std::ios::binary);
    readContextBase(instream2, m, p, r, gens, ords);
    FHEcontext context(m, p, r, gens, ords);
    instream2 >> context;
    printf("%f\n", context.securityLevel());
    /// standing alone PubKey;
    FHEPubKey pk(context);
    instream >> pk;
    /// To test the pk is exactly the right one; we test whether the sk
    /// can correctly decrypt the ciphertext that generated by this pk.
    Ctxt c(pk);
    pk.Encrypt(c, NTL::to_ZZX(10));
    c *= c;

    std::ifstream insk("sk.sk", std::ios::binary);
    FHESecKey sk(context);
    insk >> sk;

    NTL::ZZX poly;
    sk.Decrypt(poly, c);
    std::cout << poly << "\n"; // [100]
}


int main() {
    gen();
    test();
}
